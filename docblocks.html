<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Doxygen: Documenting the code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Doxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('docblocks.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">为代码写用于生成文档的注释 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>内容列表</h3>
<ul><li class="level1"><a href="#specialblock">特殊文档块</a><ul><li class="level2"><a href="#cppblock">类C语言的注释块(C/ C++ / C# /Objective-C/PHP/Java)</a><ul><li class="level3"><a href="#memberdoc">将文档放在成员之后</a></li>
<li class="level3"><a href="#docexamples">例子</a></li>
<li class="level3"><a href="#structuralcommands">其他地方的文档</a></li>
</ul>
</li>
<li class="level2"><a href="#pythonblocks">Python中的注释块</a></li>
<li class="level2"><a href="#vhdlblocks">VHDL中的注释块</a></li>
<li class="level2"><a href="#fortranblocks">Fortran中的注释块</a></li>
<li class="level2"><a href="#tclblocks">Tcl中的注释块</a></li>
</ul>
</li>
<li class="level1"><a href="#docstructure">注释块的剖析</a></li>
</ul>
</div>
<div class="textblock"><p>本章包括两个主题:</p><ol type="1">
<li>如何在代码中添加注释，以便doxygen将其合并到生成的文档中。这将在<a class="el" href="docblocks.html#specialblock">下一节</a>中进一步详细说明。</li>
<li>构造注释块内容的方法，使输出看起来很好，如<a class="el" href="docblocks.html#docstructure">注释块的剖析</a>小节所述。</li>
</ol>
<h1><a class="anchor" id="specialblock"></a>
特殊文档块</h1>
<p>特殊的注释块是带有一些附加标记的C或C++风格的注释块，因此doxygen知道它是一段结构化文本，需要在生成的文档中结束<a class="el" href="docblocks.html#cppblock">下一节</a> 介绍doxygen支持的各种样式。</p>
<p>对于Python、VHDL、Fortran和Tcl代码，有不同的注释约定，分别可以在<a class="el" href="docblocks.html#pythonblocks">Python的注释块</a>、<a class="el" href="docblocks.html#vhdlblocks">VHDL的注释块</a>、<a class="el" href="docblocks.html#fortranblocks">Fortran的注释块</a>和T<a class="el" href="docblocks.html#tclblocks">cl的注释块 </a> 中找到。</p>
<h2><a class="anchor" id="cppblock"></a>
类C语言的注释块(C/ C++ / C# /Objective-C/PHP/Java)</h2>
<p>对于代码中的每个实体，都有两种(在某些情况下是三种)类型的描述，它们共同构成该实体的文档;<em>brief</em>（简要）描述 和<em>detailed</em>（详细） 都是可选的。对于方法和函数，还有第三种类型的描述，即所谓的<em>体</em> 描述，它由方法或函数体中发现的所有注释块连接而成。</p>
<p>允许有多个简短或详细的描述(但不建议这样做，因为描述出现的顺序没有指定)。</p>
<p>顾名思义，一个简短的描述是一个简短的一行代码，而详细的描述提供了更长的、更详细的文档。“体”描述还可以作为详细描述，或者描述实现细节的集合。对于HTML输出，简要描述还用于在引用项的地方提供工具提示。</p>
<p>有几种方法可以将注释块标记为详细描述:</p><ol>
<li>
<p class="startli">您可以使用Javadoc风格，它由一个以两个*开头的C风格的注释块组成，如下所示:</p>
<pre class="fragment">/**
 * ... 文本 ...
 */
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">或者您可以使用Qt样式，并在打开一个C样式的注释块后添加一个感叹号(!)，如下例所示:</p>
<pre class="fragment">/*!
 * ... 文本 ...
 */
</pre><p class="interli">在这两种情况下，中间*都是可选的，所以</p>
<pre class="fragment">/*!
 ... 文本 ...
*/
</pre><p class="interli">也是可以的。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">第三种方法是使用<em>至少两个</em> C++注释行组成的块，其中每一行都以一个额外的斜杠或感叹号开始。以下是这两种情况的例子:</p>
<pre class="fragment">///
/// ... 文本 ...
///
</pre><p class="interli">or</p>
<pre class="fragment">//!
//!... 文本 ...
//!
</pre><p class="interli">注意，在本例中，一个空白行结束一个文档块。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">有些人喜欢在文档中显示他们的注释块。为此目的，你可采用以下方法:</p>
<pre class="fragment">/********************************************//**
 *  ... 文本
 ***********************************************/
</pre><p> (注意结束普通注释块并开始一个特殊注释块的两个斜杠)。</p>
<p class="interli">或</p>
<pre class="fragment">/////////////////////////////////////////////////
/// ... 文本 ...
/////////////////////////////////////////////////
</pre><p class="interli">或</p>
<pre class="fragment">/************************************************
 *  ... 文本
 ***********************************************/
</pre><p class="interli">只要使用JAVADOC_BANNER = YES。 </p><div class="fragment"><div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * javadoc风格（C风格）注释的简史。</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * 这是典型的javadoc风格的注释。它以两个</span></div>
<div class="line"><span class="comment"> * 星号开始</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @param theory 即使只有一种可能的统一理论。它只是一组</span></div>
<div class="line"><span class="comment"> *               规则和方程。</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> cstyle( <span class="keywordtype">int</span> theory );</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*******************************************************************************</span></div>
<div class="line"><span class="comment"> * JavaDoc风格(C风格)横幅注释的简史。</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * 这是典型的javadoc风格的“横幅”注释。它以一个正斜杠开始，后面跟着n</span></div>
<div class="line"><span class="comment"> * 个星号，其中n > 2。这样写</span></div>
<div class="line"><span class="comment"> * 是为了让正在阅读源代码的开发人员</span></div>
<div class="line"><span class="comment"> * 更加“可见”。</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * 通常，开发人员没有意识到这不是(默认情况下)一个有效的</span></div>
<div class="line"><span class="comment"> * Doxygen注释块!</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * 但是，只要将JAVADOC_BLOCK = YES添加到Doxyfile中，它就会像预期的那样工作。</span></div>
<div class="line"><span class="comment"> * 的那样工作。</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * 这种注释风格与clang格式很好地配合。</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @param theory 即使只有一种可能的统一理论。它只是</span></div>
<div class="line"><span class="comment"> *               一组规则和方程。</span></div>
<div class="line"><span class="comment"> ******************************************************************************/</span></div>
<div class="line"><span class="keywordtype">void</span> javadocBanner( <span class="keywordtype">int</span> theory );</div>
<div class="line"> </div>
<div class="line"><span class="comment">/***************************************************************************/</span><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * 一个简短的doxygen风格的横幅注释的历史。</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * 这是一个doxygen风格的C风格的“横幅”评论。它以一个“普通”</span></div>
<div class="line"><span class="comment"> * 注释开始，然后在第一行末尾被转换为一个“特殊”注释块。</span></div>
<div class="line"><span class="comment"> * 这样写是为了让正在阅读源代码的</span></div>
<div class="line"><span class="comment"> * 开发人员更加“可见”。</span></div>
<div class="line"><span class="comment"> * 这种注释风格在clang格式下表现很差。</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @param theory 即使只有一种可能的统一理论。它只是</span></div>
<div class="line"><span class="comment"> *               一组规则和方程。</span></div>
<div class="line"><span class="comment"> ******************************************************************************/</span></div>
<div class="line"><span class="keywordtype">void</span> doxygenBanner( <span class="keywordtype">int</span> theory );</div>
</div><!-- fragment --><p>  
 单击 <a href="examples/javadoc-banner/html/index.html">此处</a>
 查看由doxygen生成的相应HTML文档。
  </p>
<p class="endli"></p>
</li>
</ol>
<p>关于简要说明，也有几种可能性: </p><ol>
<li>
<p class="startli">您可以将<a class="el" href="commands.html#cmdbrief">\brief</a> 命令与上面的注释块之一一起使用。该命令在段落末尾结束，因此详细描述在空行之后。</p>
<p class="interli">这是一个示例</p>
<pre class="fragment">/*! \brief 简要描述.
 *         简要描述续。
 *
 *  详细描述从这里开始。
 */
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">如果在配置文件中将<a class="el" href="config.html#cfg_javadoc_autobrief">JAVADOC_AUTOBRIEF</a> 设置为 <code>YES</code> ，那么使用Javadoc风格的注释块将自动开始一个简短的描述，该描述以第一个点结束，然后是空格或新行。举个例子:</p>
<pre class="fragment">/** 以这个点结束的简短描述。这里细节
 *  如下。
 */
</pre><p> 对于多行特殊C++注释，该选项具有相同的效果: </p><pre class="fragment">/// 以这个点结束的简短描述。这里细节
/// 如下。
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">第三个选项是使用一个特殊的C++风格的注释，它不会跨越超过一行。这里有两个例子: </p><pre class="fragment">/// 简要描述
/** 详细描述 */
</pre><p class="interli">或</p>
<pre class="fragment">//! 简要描述

//! 详细描述 
//! 开始于此
</pre><p class="interli">注意最后一个示例中的空白行，这是将简要描述与包含详细描述的块分离所必需的。在这种情况下，<a class="el" href="config.html#cfg_javadoc_autobrief">JAVADOC_AUTOBRIEF</a> 也应该设置为 <code>NO</code>。</p>
<p class="endli"></p>
</li>
</ol>
<p>正如你所看到的，doxygen是非常灵活的。如果你有多个详细的描述，如下图所示:</p>
<pre class="fragment">//!简短的描述，这实际上
//! 是一个详细的描述，因为它跨越了多行。
/*! 另一个详细描述!
 */
</pre><p>他们将会被加入。注意，如果描述位于代码中的不同位置，情况也是如此!在这种情况下，顺序将取决于doxygen解析代码的顺序。</p>
<p>与大多数其他文档系统不同，doxygen还允许将成员的文档(包括全局函数)放在<em>定义</em>的前面。这样，文档就可以放在源文件中，而不是头文件中。这使头文件保持紧凑，并允许成员的实现者更直接地访问文档。作为折衷，可以将简要描述放在声明之前，而将详细描述放在成员定义之前。</p>
<h3><a class="anchor" id="memberdoc"></a>
将文档放在成员之后</h3>
<p>如果希望为文件、结构、联合、类或枚举的成员编制文档，有时需要将文档块放在成员之后，而不是之前。为此，您必须在注释块中添加一个额外的&lt; 标记。注意，这也适用于函数的参数。</p>
<p>下面是一些例子: </p><pre class="fragment">int var; /*!&lt; 在一个成员之后的详细描述 */
</pre><p> 此块可用于将Qt样式的详细文档块放在成员<em>之后</em>。其他的方法是:</p><pre class="fragment">int var; /**&lt; 在一个成员之后的详细描述 */
</pre><p> 或 </p><pre class="fragment">int var; //!&lt; 在一个成员之后的详细描述
         //!&lt; 
</pre><p> 或 </p><pre class="fragment">int var; ///&lt; 在一个成员之后的详细描述
         ///&lt; 
</pre><p>大多数情况下，人们只想在成员之后加上简短的描述。具体做法如下: </p><pre class="fragment">int var; //!&lt; 在一个成员之后的简短描述
</pre><p> 或 </p><pre class="fragment">int var; ///&lt; 在一个成员之后的简短描述
</pre><p>对于函数，可以使用<a class="el" href="commands.html#cmdparam">@param</a> 命令记录参数，然后使用<code>[in]</code>, <code>[out]</code>、 <code>[in,out]</code> 记录方向。对于内联文档，也可以从direction属性开始，例如。 </p><pre class="fragment">void foo(int v /**&lt; [in] 输入参数v的文档。 */);
</pre><p>注意，这些块具有与前一节中的特殊注释块相同的结构和含义，只有&lt; 表示成员位于块的前面，而不是块的后面。</p>
<p>下面是使用这些注释块的一个例子: </p><div class="fragment"><div class="line"><span class="comment">/*! 一个测试类 */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Afterdoc_Test</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    /** 一个枚举类型 </span></div>
<div class="line"><span class="comment">     *  文档块不能放在枚举之后! </span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keyword">enum</span> EnumType</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">int</span> EVal1,     <span class="comment">/**&lt; 枚举值 1 */</span></div>
<div class="line">      <span class="keywordtype">int</span> EVal2      <span class="comment">/**&lt; 枚举值 2 */</span></div>
<div class="line">    };</div>
<div class="line">    <span class="keywordtype">void</span> member();   <span class="comment">//!&lt; 一个成员函数</span></div>
<div class="line"><span class="comment"></span>    </div>
<div class="line">  <span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">int</span> value;       <span class="comment">/*!&lt; 一个整数值 */</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>  
 单击<a href="examples/afterdoc/html/class_afterdoc___test.html">此处</a>
 查看由doxygen生成的相应HTML文档。
  </p>
<dl class="section warning"><dt>警告</dt><dd>这些块只能用于记录 <em>成员</em> 和 <em>参数</em>，它们不能用于记录文件、类、联合、结构、组、名称空间和枚举本身。此外，在下一节中提到的结构命令(比如<code>\class</code>)在这些注释块中是不允许的。.</dd></dl>
<h3><a class="anchor" id="docexamples"></a>
例子</h3>
<p>下面是一个使用Qt风格的C++代码的例子: </p><div class="fragment"><div class="line"><span class="comment">//!  一个测试类 </span></div>
<div class="line"><span class="comment"></span><span class="comment">/*!</span></div>
<div class="line"><span class="comment">  更详细的类描述。</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>QTstyle_Test</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! 一个枚举类型</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /*! 更详细的枚举描述 */</span></div>
<div class="line">    <span class="keyword">enum</span> TEnum { </div>
<div class="line">                 TVal1, <span class="comment">/*!&lt; 枚举值 TVal1. */</span>  </div>
<div class="line">                 TVal2, <span class="comment">/*!&lt; 枚举值 TVal2. */</span>  </div>
<div class="line">                 TVal3  <span class="comment">/*!&lt; 枚举值 TVal3. */</span>  </div>
<div class="line">               } <span class="comment"></span></div>
<div class="line"><span class="comment">         //! 枚举指针</span></div>
<div class="line"><span class="comment"></span><span class="comment">         /*! 细节 */</span></div>
<div class="line">         *enumPtr, <span class="comment"></span></div>
<div class="line"><span class="comment">         //! 枚举变量 </span></div>
<div class="line"><span class="comment"></span><span class="comment">         /*! 细节 */</span></div>
<div class="line">         enumVar;  </div>
<div class="line">    <span class="comment"></span></div>
<div class="line"><span class="comment">    //! 构造函数</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /*!</span></div>
<div class="line"><span class="comment">      构造函数的更详细的类描述。</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    QTstyle_Test();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! 析构函数 </span></div>
<div class="line"><span class="comment"></span><span class="comment">    /*!</span></div>
<div class="line"><span class="comment">      析构函数的更详细的类描述。</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">   ~QTstyle_Test();</div>
<div class="line">    <span class="comment"></span></div>
<div class="line"><span class="comment">    //! 一个普通成员，接受两个参数并返回一个整数值。</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /*!</span></div>
<div class="line"><span class="comment">      \param a 一个整型参数</span></div>
<div class="line"><span class="comment">      \param s 一个cosnt字符指针</span></div>
<div class="line"><span class="comment">      \return 测试结果</span></div>
<div class="line"><span class="comment">      \sa QTstyle_Test(), ~QTstyle_Test(), testMeToo() and publicVar()</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    <span class="keywordtype">int</span> testMe(<span class="keywordtype">int</span> a,<span class="keyword">const</span> <span class="keywordtype">char</span> *s);</div>
<div class="line">       <span class="comment"></span></div>
<div class="line"><span class="comment">    //! 一个纯虚函数</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /*!</span></div>
<div class="line"><span class="comment">      \sa testMe()</span></div>
<div class="line"><span class="comment">      \param c1 第一个参数</span></div>
<div class="line"><span class="comment">      \param c2 第二个参数</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> testMeToo(<span class="keywordtype">char</span> c1,<span class="keywordtype">char</span> c2) = 0;</div>
<div class="line">   <span class="comment"></span></div>
<div class="line"><span class="comment">    //! 公用变量</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /*!</span></div>
<div class="line"><span class="comment">      细节</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    <span class="keywordtype">int</span> publicVar;</div>
<div class="line">       <span class="comment"></span></div>
<div class="line"><span class="comment">    //! 函数类型变量</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /*!</span></div>
<div class="line"><span class="comment">      细节</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    int (*handler)(<span class="keywordtype">int</span> a,<span class="keywordtype">int</span> b);</div>
<div class="line">};</div>
<div class="line"> </div>
</div><!-- fragment --><p>  
 单击 <a href="examples/qtstyle/html/class_q_tstyle___test.html">此处</a>
 查看由doxygen生成的相应HTML文档。
  </p>
<p>简要描述包含在类、名称空间或文件的成员概述中，并使用小的斜体字体打印(通过将配置文件中的<a class="el" href="config.html#cfg_brief_member_desc">BRIEF_MEMBER_DESC</a> 设置为 <code>NO</code>，可以隐藏此描述)。默认情况下，简短描述将成为详细描述的第一句话(但是可以通过将<a class="el" href="config.html#cfg_repeat_brief">REPEAT_BRIEF</a> 标记设置为 <code>NO</code>来更改这一点)。对于Qt样式，简短描述和详细描述都是可选的。</p>
<p>默认情况下，Javadoc样式文档块的行为与Qt样式文档块相同。然而，这并不符合Javadoc规范，在Javadoc规范中，文档块的第一句话被自动视为一个简短的描述。要启用此行为，您应该在配置文件中将<a class="el" href="config.html#cfg_javadoc_autobrief">JAVADOC_AUTOBRIEF</a>  设置为YES。如果您启用此选项，并且希望在一个句子中间加上一个点而不结束它，则应该在其后加上反斜杠和空格。举个例子: </p><pre class="fragment">  /** 简要描述 (例如\ 只用几句话)。 细节跟进。 */
</pre><p>下面是与上面相同的代码段，这次使用<a class="el" href="config.html#cfg_javadoc_autobrief">JAVADOC_AUTOBRIEF</a>设置为 YES: </p><div class="fragment"><div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> *  一个测试类。更详细的类描述。</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Javadoc_Test</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /** </span></div>
<div class="line"><span class="comment">     * 一个枚举类型</span></div>
<div class="line"><span class="comment">     * 更详细的关于枚举描述</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">enum</span> TEnum { </div>
<div class="line">          TVal1, <span class="comment">/**&lt; 枚举值 TVal1. */</span>  </div>
<div class="line">          TVal2, <span class="comment">/**&lt; 枚举值 TVal2. */</span>  </div>
<div class="line">          TVal3  <span class="comment">/**&lt; 枚举值 TVal3. */</span>  </div>
<div class="line">         } </div>
<div class="line">       *enumPtr, <span class="comment">/**&lt; 枚举指针。详述 */</span></div>
<div class="line">       enumVar;  <span class="comment">/**&lt; 枚举变量。详述 */</span></div>
<div class="line">       <span class="comment"></span></div>
<div class="line"><span class="comment">      /**</span></div>
<div class="line"><span class="comment">       * 构造函数</span></div>
<div class="line"><span class="comment">       * 构造函数的更详细描述。</span></div>
<div class="line"><span class="comment">       */</span></div>
<div class="line">      Javadoc_Test();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">      /**</span></div>
<div class="line"><span class="comment">       * 析构函数</span></div>
<div class="line"><span class="comment">       * 析构函数的更详细描述。</span></div>
<div class="line"><span class="comment">       */</span></div>
<div class="line">     ~Javadoc_Test();</div>
<div class="line">    <span class="comment"></span></div>
<div class="line"><span class="comment">      /**</span></div>
<div class="line"><span class="comment">       * 一个普通成员，接受两个参数并返回一个整数值。</span></div>
<div class="line"><span class="comment">       * @param a 一个整数参数。</span></div>
<div class="line"><span class="comment">       * @param s 一个常量字符指针。</span></div>
<div class="line"><span class="comment">       * @see Javadoc_Test()</span></div>
<div class="line"><span class="comment">       * @see ~Javadoc_Test()</span></div>
<div class="line"><span class="comment">       * @see testMeToo()</span></div>
<div class="line"><span class="comment">       * @see publicVar()</span></div>
<div class="line"><span class="comment">       * @return 测试结果</span></div>
<div class="line"><span class="comment">       */</span></div>
<div class="line">       <span class="keywordtype">int</span> testMe(<span class="keywordtype">int</span> a,<span class="keyword">const</span> <span class="keywordtype">char</span> *s);</div>
<div class="line">       <span class="comment"></span></div>
<div class="line"><span class="comment">      /**</span></div>
<div class="line"><span class="comment">       * 一个纯虚函数</span></div>
<div class="line"><span class="comment">       * @see testMe()</span></div>
<div class="line"><span class="comment">       * @param c1 第一个参数</span></div>
<div class="line"><span class="comment">       * @param c2 第二个参数</span></div>
<div class="line"><span class="comment">       */</span></div>
<div class="line">       <span class="keyword">virtual</span> <span class="keywordtype">void</span> testMeToo(<span class="keywordtype">char</span> c1,<span class="keywordtype">char</span> c2) = 0;</div>
<div class="line">   <span class="comment"></span></div>
<div class="line"><span class="comment">      /** </span></div>
<div class="line"><span class="comment">       * 功用变量</span></div>
<div class="line"><span class="comment">       * 细节。</span></div>
<div class="line"><span class="comment">       */</span></div>
<div class="line">       <span class="keywordtype">int</span> publicVar;</div>
<div class="line">       <span class="comment"></span></div>
<div class="line"><span class="comment">      /**</span></div>
<div class="line"><span class="comment">       * 函数类型变量</span></div>
<div class="line"><span class="comment">       * 细节。</span></div>
<div class="line"><span class="comment">       */</span></div>
<div class="line">       int (*handler)(<span class="keywordtype">int</span> a,<span class="keywordtype">int</span> b);</div>
<div class="line">};</div>
<div class="line"> </div>
</div><!-- fragment --><p>  
 单击<a href="examples/jdstyle/html/class_javadoc___test.html">此处</a>
 查看由doxygen生成的相应HTML文档。
  </p>
<p>类似地，如果希望Qt样式文档块的第一句话自动被当作简短描述，可以在配置文件中将<a class="el" href="config.html#cfg_qt_autobrief">QT_AUTOBRIEF</a> 设置为YES。</p>
<h3><a class="anchor" id="structuralcommands"></a>
其他地方的文档</h3>
<p>在前一节的示例中，注释块总是位于文件、类或名称空间的声明或定义<em>前面</em> ，或者位于其中一个成员的 <em>前面</em> 或 <em>后面</em> 。虽然这样做通常很舒服，但有时可能有理由将文档放到其他地方。为了记录一个文件，这甚至是必需的，因为没有“在文件前面”这样的东西。</p>
<p>Doxygen允许您将文档块实际放置在任何地方(例外情况是在函数体中或普通的C风格注释块中)。</p>
<p>不直接在项目之前(或之后)放置文档块的代价是需要在文档块中放置<br  />
 结构命令，这会导致一些信息重复。因此，在实践中，您应该<em>避免</em> 使用结构化命令，<em>除非</em> 其他需求迫使您这样做。</p>
<p>结构命令(与<a class="el" href="commands.html#cmd_intro">所有其他命令</a>一样)以反斜杠(<code>\</code>)，如果您喜欢Javadoc风格，可以使用艾特符号(<code>@</code>) ，然后是命令名和一个或多个参数。例如，如果你想在上面的例子中记录类<code>Test</code>，你也可以把下面的文档块放在doxygen读取的输入中:</p><pre class="fragment">/*! \class Test
    \brief test类

    更详细的类描述。
*/
</pre><p>这里使用特殊的命令<code>\class</code> 来指示注释块包含用于类<code>Test</code>的文档。其他结构命令包括: </p><ul>
<li>
<code>\struct</code> C结构体的文档注释。 </li>
<li>
<code>\union</code> 联合体的文档注释。</li>
<li>
<code>\enum</code>枚举类型的文档注释。 </li>
<li>
<code>\fn</code> 函数的文档注释。 </li>
<li>
<code>\var</code> 变量 、类型定义 或 枚举值的文档注释。 </li>
<li>
<code>\def</code> #define的文档注释。 </li>
<li>
<code>\typedef</code> 类型定义的文档注释。</li>
<li>
<code>\file</code> 文件的文档注释。 </li>
<li>
<code>\namespace</code> 名字空间的文档注释。 </li>
<li>
<code>\package</code> Java包的文档注释。 </li>
<li>
<code>\interface</code> IDL接口的文档注释。 </li>
</ul>
<p>有关这些命令和许多其他命令的详细信息，请参见<a class="el" href="commands.html">特殊命令</a> 一节。</p>
<p>要文档注释C++类的成员，还必须文档注释类本身。名称空间也是如此。要文档注释全局C函数、typedef、enum或预处理器定义，必须首先文档注释包含它的文件(通常是头文件，因为该文件包含导出到其他源文件的信息)。</p>
<dl class="section attention"><dt>注意</dt><dd>让我们重复一遍，因为它经常被忽略:要文档注释全局对象(函数、typedefs、枚举、宏等)，您<em>必须</em>文档注释定义它们的文件。换句话说，该文件中<em>必须</em>至少有一个<pre class="fragment">/*! \file */ </pre> 或一个<pre class="fragment">/** @file */ </pre> 行。</dd></dl>
<p>下面是一个名为<code>structcmd.h</code> 的C头文件的例子，它使用结构命令进行了文档化: </p><div class="fragment"><div class="line"><span class="comment">/*! \file structcmd.h</span></div>
<div class="line"><span class="comment">    \brief 一个文档化的文件</span></div>
<div class="line"><span class="comment">    </span></div>
<div class="line"><span class="comment">    细节</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*! \def MAX(a,b)</span></div>
<div class="line"><span class="comment">    \brief 一个宏，返回\a a和\ b b的最大值。</span></div>
<div class="line"><span class="comment">   </span></div>
<div class="line"><span class="comment">    细节</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*! \var typedef unsigned int UINT32</span></div>
<div class="line"><span class="comment">    \brief 一个为a的类型定义</span></div>
<div class="line"><span class="comment">    </span></div>
<div class="line"><span class="comment">    细节</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*! \var int errno</span></div>
<div class="line"><span class="comment">    \brief 包含最后一个错误代码。</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    \warning 非线程安全的！</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*! \fn int open(const char *pathname,int flags)</span></div>
<div class="line"><span class="comment">    \brief 打开文件描述符。</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    \param pathname 描述符的名称。</span></div>
<div class="line"><span class="comment">    \param flags 打开标志</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*! \fn int close(int fd)</span></div>
<div class="line"><span class="comment">    \brief 关闭文件描述符\a fd。</span></div>
<div class="line"><span class="comment">    \param fd 关闭的描述符。</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*! \fn size_t write(int fd,const char *buf, size_t count)</span></div>
<div class="line"><span class="comment">    \brief 将\a count字节从\a buf 写入文件描述符\a fd.</span></div>
<div class="line"><span class="comment">    \param fd 要写入的描述符。</span></div>
<div class="line"><span class="comment">    \param buf 要写入的数据缓冲区。</span></div>
<div class="line"><span class="comment">    \param count 要写的字节数。</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*! \fn int read(int fd,char *buf,size_t count)</span></div>
<div class="line"><span class="comment">    \brief 从文件描述符读取字节。</span></div>
<div class="line"><span class="comment">    \param fd 要从中读取的描述符。</span></div>
<div class="line"><span class="comment">    \param buf 要读入的缓冲区</span></div>
<div class="line"><span class="comment">    \param count 要读取的字节数。</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define MAX(a,b) (((a)&gt;(b))?(a):(b))</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> UINT32;</div>
<div class="line"><span class="keywordtype">int</span> errno;</div>
<div class="line"><span class="keywordtype">int</span> open(<span class="keyword">const</span> <span class="keywordtype">char</span> *,<span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">int</span> close(<span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">size_t</span> write(<span class="keywordtype">int</span>,<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">size_t</span>);</div>
<div class="line"><span class="keywordtype">int</span> read(<span class="keywordtype">int</span>,<span class="keywordtype">char</span> *,<span class="keywordtype">size_t</span>);</div>
</div><!-- fragment --><p>  
 单击 <a href="examples/structcmd/html/structcmd_8h.html">此处</a>
 查看由doxygen生成的相应HTML文档。
  </p>
<p>因为上面示例中的每个注释块都包含一个结构命令，所以可以将所有注释块移动到另一个位置或输入文件(例如源文件)，而不影响生成的文档。这种方法的缺点是原型是重复的，所以所有的更改都必须进行两次!因此，您应该首先考虑是否真的需要这样做，并尽可能避免结构命令。我经常收到一些包含\fn命令的示例，它们位于函数前面的注释块中。很明显，在这种情况下\fn命令是冗余的，并且只会导致问题。</p>
<p>当您将注释块放入具有以下扩展名<code>.dox</code>、 <code>.txt</code>或<code>.doc</code> 之一的文件中时，doxygen将从文件列表中隐藏该文件。</p>
<p>如果您有一个doxygen无法解析但仍然希望对其进行文档化的文件，您可以使用<a class="el" href="commands.html#cmdverbinclude">\verbinclude</a>，(例如)按原样显示它。</p>
<pre class="fragment">/*! \file myscript.sh
 *  看看这个漂亮的脚本:
 *  \verbinclude myscript.sh
 */
</pre><p>确保脚本在<a class="el" href="config.html#cfg_input">INPUT</a> 中显式列出，或者<a class="el" href="config.html#cfg_file_patterns">FILE_PATTERNS</a> 包含<code>.sh</code> 扩展名，并且脚本可以在<a class="el" href="config.html#cfg_example_path">EXAMPLE_PATH</a>设置的路径中找到。</p>
<h2><a class="anchor" id="pythonblocks"></a>
Python中的注释块</h2>
<p>对于Python，有一种使用所谓文档字符串记录代码的标准方法。这些字符串存储在<code><b>doc</b></code> 中，可以在运行时检索。Doxygen将提取这些注释，并假设它们必须以预先格式化的方式表示。</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;&quot;&quot;@package docstring</span></div>
<div class="line"><span class="stringliteral">文档注释这个模块</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">更多细节。</span></div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>func():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;为一个函数添加文档注释</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    更多细节。</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PyClass:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;为一个类添加文档注释</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    更多细节。</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">   </div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;构造函数&quot;&quot;&quot;</span></div>
<div class="line">        self._memVar = 0;</div>
<div class="line">   </div>
<div class="line">    <span class="keyword">def </span>PyMethod(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;为一个方法添加文档注释&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">pass</span></div>
<div class="line">     </div>
</div><!-- fragment --><p>  
 单击 <a href="examples/docstring/html/index.html">此处</a>
 查看由doxygen生成的相应HTML文档。
  </p>
<p>注意，在这种情况下，不支持doxygen的任何<a class="el" href="commands.html#cmd_intro">特殊命令</a>。</p>
<p>还有一种方法可以使用以“##”开头的注释来记录Python代码。这些类型的注释块更符合doxygen支持的其他语言的文档块的工作方式，这也允许使用特殊命令。</p>
<p>下面是同样的例子，但现在使用doxygen风格的注释:</p>
<div class="fragment"><div class="line"><span class="comment">## @package pyexample</span></div>
<div class="line"><span class="comment">#  文档注释这个模块</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment">#  更多细节。</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">## 为一个函数添加文档注释</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment">#  更多细节。</span></div>
<div class="line"><span class="keyword">def </span>func():</div>
<div class="line">    <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">## 为一个类添加文档注释</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment">#  更多细节。</span></div>
<div class="line"><span class="keyword">class </span>PyClass:</div>
<div class="line">   </div>
<div class="line">    <span class="comment">## 构造函数</span></div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        self._memVar = 0;</div>
<div class="line">   </div>
<div class="line">    <span class="comment">## 为一个方法添加文档注释</span></div>
<div class="line"><span class="comment">    #  @param self 该对象指针</span></div>
<div class="line">    <span class="keyword">def </span>PyMethod(self):</div>
<div class="line">        <span class="keywordflow">pass</span></div>
<div class="line">     </div>
<div class="line">    <span class="comment">## 一个类变量</span></div>
<div class="line">    classVar = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">## @var _memVar</span></div>
<div class="line"><span class="comment">    #  一个成员变量</span></div>
</div><!-- fragment --><p>  
 单击 <a href="examples/pyexample/html/index.html">此处</a>
 查看由doxygen生成的相应HTML文档。
  </p>
<p>由于python看起来更像Java，而不像C或C++，所以您应该在配置文件中将<a class="el" href="config.html#cfg_optimize_output_java">OPTIMIZE_OUTPUT_JAVA</a> 设置为 <code>YES</code>。</p>
<h2><a class="anchor" id="vhdlblocks"></a>
VHDL中的注释块</h2>
<p>对于VHDL，注释通常以"--"开头。Doxygen将提取以"--!"开头的注释。在VHDL中只有两种类型的注释块; 一行"--!" 注释表示一个简短的描述，多行"--!" 注释(其中每一行重复使用前缀"--!")表示一个详细的描述。</p>
<p>注释总是位于被文档注释的项的前面，但有一个例外:对于端口，注释也可以位于项之后，然后作为端口的简要描述处理。</p>
<p>下面是一个带有doxygen注释的VHDL文件示例</p>
<div class="fragment"><div class="line"><span class="comment">-------------------------------------------------------</span></div>
<div class="line"><span class="comment">--! @file</span></div>
<div class="line"><span class="comment">--! @brief 2:1 Mux使用之选</span></div>
<div class="line"><span class="comment">-------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">--! 使用标准库</span></div>
<div class="line"><span class="vhdlkeyword">library </span><span class="keywordflow">ieee</span>;</div>
<div class="line"><span class="comment">--! 使用逻辑元素</span></div>
<div class="line"><span class="vhdlkeyword">    use </span>ieee.std_logic_1164.<span class="keywordflow">all</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">--! Mux实体简介</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">--! 关于这个的详细描述 </span></div>
<div class="line"><span class="comment">--! mux设计元素。</span></div>
<div class="line"><span class="keywordflow">entity </span>mux_using_with <span class="keywordflow">is</span></div>
<div class="line">    <span class="keywordflow">port</span> <span class="vhdlchar">(</span></div>
<div class="line">        <span class="vhdlchar">din_0</span>   <span class="vhdlchar">:</span> <span class="keywordflow">in</span>  <span class="keywordtype">std_logic</span>;<span class="comment"> --! Mux 第一个输入</span></div>
<div class="line">        <span class="vhdlchar">din_1</span>   <span class="vhdlchar">:</span> <span class="keywordflow">in</span>  <span class="keywordtype">std_logic</span>;<span class="comment"> --! Mux 第二个输入</span></div>
<div class="line">        <span class="vhdlchar">sel</span>     <span class="vhdlchar">:</span> <span class="keywordflow">in</span>  <span class="keywordtype">std_logic</span>;<span class="comment"> --! 选择输入</span></div>
<div class="line">        <span class="vhdlchar">mux_out</span> <span class="vhdlchar">:</span> <span class="keywordflow">out</span> <span class="keywordtype">std_logic</span><span class="comment">  --! Mux 输出/span></div>
<div class="line">    <span class="vhdlchar">)</span>;</div>
<div class="line"><span class="keywordflow">end</span> <span class="keywordflow">entity</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">--! @brief MUX的体系结构定义</span></div>
<div class="line"><span class="comment">--! @details 关于这个mux元素的更多细节。</span></div>
<div class="line"><span class="keywordflow">architecture</span> behavior <span class="keywordflow">of</span> mux_using_with <span class="keywordflow">is</span></div>
<div class="line"><span class="vhdlkeyword">begin</span></div>
<div class="line">    <span class="keywordflow">with</span> <span class="vhdlchar">(</span><span class="vhdlchar">sel</span><span class="vhdlchar">)</span> <span class="keywordflow">select</span></div>
<div class="line">    <span class="vhdlchar">mux_out</span> <span class="vhdlchar">&lt;=</span> <span class="vhdlchar">din_0</span> <span class="keywordflow">when</span> <span class="vhdlchar">&#39;</span><span class="vhdllogic"></span><span class="vhdllogic">0</span><span class="vhdlchar">&#39;</span><span class="vhdlchar">,</span></div>
<div class="line">               <span class="vhdlchar">din_1</span> <span class="keywordflow">when</span> <span class="keywordflow">others</span>;</div>
<div class="line"><span class="keywordflow">end</span> <span class="keywordflow">architecture</span>;</div>
<div class="line"> </div>
</div><!-- fragment --><p>  
 单击 <a href="examples/mux/html/index.html"> 此处</a>
查看由doxygen生成的相应HTML文档。
  </p>
<p>为了得到正确的输出，您需要在配置文件中将<a class="el" href="config.html#cfg_optimize_output_vhdl">OPTIMIZE_OUTPUT_VHDL</a> 设置为 <code>YES</code> 。这还将影响其他一些设置。当它们还没有被正确设置时，doxygen将产生一个警告，告诉哪些设置被否决了。</p>
<h2><a class="anchor" id="fortranblocks"></a>
Fortran中的注释块</h2>
<p>当将doxygen用于Fortran代码时，应该将<a class="el" href="config.html#cfg_optimize_for_fortran">OPTIMIZE_FOR_FORTRAN</a> 设置为 <code>YES</code>。</p>
<p>解析器尝试猜测源代码是固定格式Fortran代码还是自由格式Fortran代码。这可能并不总是正确的。如果没有，应该使用<a class="el" href="config.html#cfg_extension_mapping">EXTENSION_MAPPING</a> 来纠正这个错误。通过设置<code>EXTENSION_MAPPING = f=FortranFixed f90=FortranFree</code> ，扩展名为<code>f</code> 的文件被解释为固定格式的Fortran代码，扩展名为<code>f90</code>的文件被解释为自由格式的Fortran代码。</p>
<p>对于Fortran而言 "!&gt;" 或 "!&lt;"开启一段注释， "!!" 或 "!&gt;"可用于将一行注释延续为多行注释。</p>
<p>下面是一个文档化的Fortran子例程的例子: </p><div class="fragment"><div class="line"><span class="comment">!&gt; 为聚合构建约束矩阵 </span></div>
<div class="line"><span class="comment">!! 方法。</span></div>
<div class="line"><span class="comment">!! @param 关于聚合的aggr信息</span></div>
<div class="line"><span class="comment">!! @todo 处理特殊情况</span></div>
<div class="line"><span class="keyword">subroutine </span>intrestbuild(A,aggr,Restrict,A_ghost)</div>
<div class="line">  <span class="keywordtype">implicit none</span></div>
<div class="line">  <span class="keywordtype">Type</span>(SpMtx), <span class="keywordtype">intent(in)</span> :: A<span class="comment"> !&lt; 精细能级矩阵</span></div>
<div class="line">  <span class="keywordtype">Type</span>(Aggrs), <span class="keywordtype">intent(in)</span> :: aggr</div>
<div class="line">  <span class="keywordtype">Type</span>(SpMtx), <span class="keywordtype">intent(out)</span> :: Restrict<span class="comment"> !&lt; 约束矩阵</span></div>
<div class="line">  <span class="comment">!...</span></div>
<div class="line"><span class="keyword">end subroutine</span></div>
</div><!-- fragment --><p>另外，你也可以使用固定格式代码的注释:</p>
<div class="fragment"><div class="line"><span class="comment">C&gt; 函数注释</span></div>
<div class="line"><span class="comment">C&gt; 注释的令一行</span></div>
<div class="line">      <span class="keyword">function </span>a(i)</div>
<div class="line"><span class="comment">C&gt; 输入参数</span></div>
<div class="line">        <span class="keywordtype">integer</span> i</div>
<div class="line">      <span class="keyword">end function </span>A</div>
</div><!-- fragment --><h2><a class="anchor" id="tclblocks"></a>
Tcl中的注释块</h2>
<p>Doxygen文档可以包含在正常的Tcl注释中。</p>
<p>要开始一个新的文档块，请用<code>##</code> 两个散列)开始一行。所有下面的注释行和延续行都将添加到这个块中。该块以不以<code>#</code> (散列符号)开头的行结束。</p>
<p>可以使用<code></code>;#&lt; (分号、散列和小于号)添加简短的文档。简短的文档也以一行结束，而不是以<code>#</code> (散列符号)开头。</p>
<p>在doxygen注释块中支持所有正常的doxygen标记。下面两段描述了唯一的例外。</p>
<p>如果doxygen注释块以只包含<code>#\code</code> 或 <code>#@code</code> 所有代码的行结束，直到只包含<code>#\endcode</code> 或 <code>#@endcode</code> 的行作为代码块添加到生成的文档中为止。</p>
<p>如果doxygen注释块以只包含<code>#\verbatim</code> 或 <code>#@verbatim</code> 所有代码的行结束，直到只包含<code>#\endverbatim</code> 或 <code>#@endverbatim</code> 的行被逐字添加到生成的文档中。</p>
<p>要检测名称空间、类、函数和变量，需要识别以下Tcl命令。文档块可以放在命令之前的行上。</p>
<ul>
<li>
<code>namespace eval ..</code> 名字空间 </li>
<li>
<code>proc ..</code> 函数 </li>
<li>
<code>variable ..</code> 变量 </li>
<li>
<code>common ..</code> 常见的变量 </li>
<li>
<code>itcl::class ..</code> 类 </li>
<li>
<code>itcl::body ..</code> 类方法体定义 </li>
<li>
<code>oo::class create ..</code> 类 </li>
<li>
<code>oo::define ..</code> OO 类定义 </li>
<li>
<code>method ..</code> 类方法定义 </li>
<li>
<code>constructor ..</code> 类构造函数 </li>
<li>
<code>destructor ..</code> 类析构函数 </li>
<li>
<code>public ..</code> 设置保护水平 </li>
<li>
<code>protected ..</code> 设置保护水平 </li>
<li>
<code>private ..</code> 设置保护水平 </li>
</ul>
<p>下面是一个使用doxygen风格注释的例子:</p>
<div class="fragment"><div class="line"><span class="comment">## \file tclexample.tcl</span></div>
<div class="line"><span class="comment"></span><span class="comment"># 文件文档</span></div>
<div class="line"><span class="comment"></span><span class="comment">#\verbatim</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"># 代码开始:\</span></div>
<div class="line"><span class="comment"></span><span class="comment">执行 tclsh &quot;$0&quot; &quot;$@&quot;</span></div>
<div class="line"><span class="comment"></span><span class="comment">#\endverbatim</span></div>
<div class="line"><span class="comment"></span><span class="comment">## 文档注释的命名空间 \c ns .</span></div>
<div class="line"><span class="comment"></span><span class="comment"># 插入代码如下:</span></div>
<div class="line"><span class="comment"></span><span class="comment">#\code</span></div>
<div class="line"><span class="comment"></span><span class="keyword">namespace</span> <span class="keyword">eval</span> ns {</div>
<div class="line">  <span class="comment">## 文档注释的处理过程 \c ns_proc .</span></div>
<div class="line"><span class="comment"></span><span class="comment">  </span><span class="comment"># \param[in] arg 若干参数</span></div>
<div class="line"><span class="comment"></span><span class="comment">  </span><span class="keyword">proc</span> ns_proc {arg} {<span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>  <span class="comment">## 文档注释的变量 \c ns_var .</span></div>
<div class="line"><span class="comment"></span><span class="comment">  </span><span class="comment"># 若干文档注释</span></div>
<div class="line"><span class="comment"></span><span class="comment">  </span><span class="keyword">variable</span> ns_var<span class="comment"></span></div>
<div class="line"><span class="comment"></span>  <span class="comment">## 文档注释的itcl类 \c itcl_class .</span></div>
<div class="line"><span class="comment"></span><span class="comment">  </span><span class="keyword">itcl::class</span> itcl_class {</div>
<div class="line">    <span class="comment">## 创建对象</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">constructor</span> {args} {<span class="keyword">eval</span> $args<span class="comment"></span><span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>    <span class="comment">## 销毁对象</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">destructor</span> {<span class="keyword">exit</span><span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>    <span class="comment">## 文档注释itcl方法 \c itcl_method_x .</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="comment"># \param[in] arg Argument</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">private</span> <span class="keyword">method</span> itcl_method_x {arg}{<span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>    <span class="comment">## 文档注释itcl方法 \c itcl_method_y .</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="comment"># \param[in] arg Argument</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">protected</span> <span class="keyword">method</span> itcl_method_y {arg} {<span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>    <span class="comment">## 文档注释itcl方法 \c itcl_method_z .</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="comment"># \param[in] arg Argument</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">public</span> <span class="keyword">method</span> itcl_method_z {arg} {<span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>    <span class="comment">## 文档注释一般itcl变量 \c itcl_Var .</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">common</span> itcl_Var<span class="comment"></span></div>
<div class="line"><span class="comment"></span>    <span class="comment">## \protectedsection</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span></div>
<div class="line">    <span class="keyword">variable</span> itcl_var1<span class="comment">;#&lt; 文档注释itcl变量 \c itcl_var1 .</span></div>
<div class="line"><span class="comment">    </span><span class="keyword">variable</span> itcl_var2<span class="comment">  </span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>  <span class="comment">## 文档注释itcl oo类 \c oo_class .</span></div>
<div class="line"><span class="comment"></span><span class="comment">  </span><span class="keyword">oo::class</span> create oo_class {</div>
<div class="line">    <span class="comment">## 创建对象</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="comment"># Configure with args</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">constructor</span> {args} {<span class="keyword">eval</span> $args<span class="comment"></span><span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>    <span class="comment">## 销毁对象</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="comment"># Exit.</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">destructor</span> {<span class="keyword">exit</span><span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>    <span class="comment">## 文档注释itcl oo变量 \c oo_var .</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="comment"># Defined inside class</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">variable</span> oo_var<span class="comment"></span></div>
<div class="line"><span class="comment"></span>    <span class="comment">## \private 文档注释itcl oo方法 \c oo_method_x .</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="comment"># \param[in] arg Argument</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">method</span> oo_method_x {arg} {<span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>    <span class="comment">## \protected 文档注释itcl oo方法 \c oo_method_y .</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="comment"># \param[in] arg Argument</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">method</span> oo_method_y {arg} {<span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>    <span class="comment">## \public 文档注释itcl oo方法 \c oo_method_z .</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="comment"># \param[in] arg 参数</span></div>
<div class="line"><span class="comment"></span><span class="comment">    </span><span class="keyword">method</span> oo_method_z {arg} {<span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span>  <span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span><span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span><span class="comment">#\endcode</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="keyword">itcl::body</span> ::ns::itcl_class::itcl_method_x {argx} {</div>
<div class="line">  <span class="keyword">puts</span> &quot;$argx OK&quot;<span class="comment"></span></div>
<div class="line"><span class="comment"></span><span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="keyword">oo::define</span> ns::oo_class {</div>
<div class="line">  <span class="comment">## \public 外部定义变量 \c oo_var_out .</span></div>
<div class="line"><span class="comment"></span><span class="comment">  </span><span class="comment"># Inside oo_class</span></div>
<div class="line"><span class="comment"></span><span class="comment">  </span><span class="keyword">variable</span> oo_var_out<span class="comment"></span></div>
<div class="line"><span class="comment"></span><span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">## 文档注释全局处理过程 \c glob_proc .</span></div>
<div class="line"><span class="comment"></span><span class="comment"># \param[in] arg 参数</span></div>
<div class="line"><span class="comment"></span><span class="keyword">proc</span> glob_proc {arg} {<span class="keyword">puts</span> $arg<span class="comment"></span>}<span class="comment"></span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="keyword">variable</span> glob_var<span class="comment">;#&lt; Documented global var \c glob_var\</span></div>
<div class="line"><span class="comment">  和换行符</span></div>
<div class="line"><span class="comment">#&lt; 继启一行</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"># 文件末尾</span><span class="comment"></span></div>
</div><!-- fragment --><p>  
 单击 <a href="examples/tclexample/html/index.html">此处</a>
 查看由doxygen生成的相应HTML文档。
  </p>
<h1><a class="anchor" id="docstructure"></a>
注释块的剖析</h1>
<p>上一节主要讨论如何让doxygen知道代码中的注释，它解释了简短描述和详细描述之间的区别，以及结构命令的使用。</p>
<p>在本节中，我们将查看注释块本身的内容。</p>
<p>Doxygen支持多种格式的注释。</p>
<p>最简单的形式是使用纯文本。这将在输出中按原样显示，非常适合进行简短的描述。</p>
<p>对于较长的描述，您通常会发现需要更多的结构，比如逐字文本块、列表或简单的表。为此，doxygen支持<a href="https://daringfireball.net/projects/markdown/syntax">Markdown</a> 语法，包括<a href="https://michelf.ca/projects/php-markdown/extra/">Markdown额外扩展</a> 的部分。</p>
<p>Markdown被设计成非常容易读和写。它的格式灵感来自纯文本邮件。Markdown非常适合简单、通用的格式，比如项目的介绍页面。Doxygen还支持直接读取标记文件。有关更多细节，请参见<a class="el" href="markdown.html">Markdown支持</a>。</p>
<p>对于编程语言特定的格式化，doxygen在标记下格式化的基础上还有两种形式的附加标记。</p>
<ol type="1">
<li><a href="https://en.wikipedia.org/wiki/Javadoc">Javadoc</a> 标记。有关doxygen支持的所有命令的完整概述，请参阅<a class="el" href="commands.html">特殊命令</a> 。</li>
<li> <a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c042926_ISO_IEC_23270_2006(E).zip">C#标准</a>中指定的<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/recommended-tags-for-documentation-comments">XML</a> 标记。有关doxygen支持的XML命令，请参阅 <a class="el" href="xmlcmds.html">XML命令</a>。</li>
</ol>
<p>如果这还不够，，doxygen还支持<a href="https://en.wikipedia.org/wiki/HTML">HTML</a> 标记语言的<a class="el" href="htmlcmds.html">子集</a>。</p>
<p> 
转到<a href="markdown.html">下一节</a> 或返回到
 <a href="index.html">索引</a>。
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
